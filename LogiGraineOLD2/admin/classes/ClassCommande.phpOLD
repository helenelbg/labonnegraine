<?php
    class Commande
    {
        public $id;
        public $id_pda;

        public function __construct()
        {
            
        }

        public static function getCommandesByPda($id_pda = 0, $today = 0)
        {
            if ( $id_pda > 0 )
            {
                $req = new DbQuery();
                $req->select('lgrm.id_order');
                $req->from('LogiGraine_pda_order', 'lgrm');
                $req->leftJoin('LogiGraine_controle', 'lgc', 'lgrm.`id_order` = lgc.`id_order`');
                $req->where('lgrm.id_pda = "'.$id_pda.'"');
                if ( $today == 1 )
                {
                    $req->where('((lgc.valide = 0) OR (lgc.valide = 1 AND lgc.date_fin LIKE "'.date('Y-m-d').' %"))');
                }
                else
                {
                    $req->where('lgc.valide = 0');
                }
                $req->orderBy('lgrm.`id_order` ASC');
                $resu = Db::getInstance(_PS_USE_SQL_SLAVE_)->executeS($req);

                $resultat = array();
                foreach($resu as $rangee)
                {
                    $resultat[] = $rangee['id_order'];
                }
                return $resultat;
            }
            return false;
        }

        public static function getProductsByOrder($id_order = 0)
        {
            if ( $id_order > 0 )
            {
                $req = new DbQuery();
                $req->select('od.product_id, od.product_attribute_id, od.product_name, od.product_quantity, od.product_quantity_refunded, product_ean13, product_reference, pa.default_on, pl.name');
                $req->from('order_detail', 'od');
                $req->leftJoin('product_attribute', 'pa', 'od.product_attribute_id = pa.id_product_attribute');
                $req->leftJoin('product_lang', 'pl', 'od.product_id = pl.id_product');
                $req->where('od.id_order = "'.$id_order.'"');
                $req->where('pl.id_lang = "1"');
                $req->where('od.product_id <> "3128" AND od.product_id <> "1850" AND od.product_id <> "1851" AND od.product_id <> "2638" AND od.product_id <> "1849"');//Carte cadeau et box
                $req->orderBy('od.`product_reference` ASC');
                
                $resu = Db::getInstance(_PS_USE_SQL_SLAVE_)->executeS($req);

                $resultat = array();
                foreach($resu as $rangee)
                {
                    $rangee['quantity_final'] = $rangee['product_quantity'] - $rangee['product_quantity_refunded'];
                    $tmp = explode('(', $rangee['product_name']);
                    /*$rangee['product_name_1'] = $tmp[0];
                    $rangee['product_name_2'] = str_replace(')', '',$tmp[1]);*/
                    $rangee['product_name_1'] = $rangee['name'];
                    $rangee['product_name_2'] = str_replace($rangee['name'], '',$rangee['product_name']);
                    $rangee['product_name_2'] = str_replace('(', '',$rangee['product_name_2']);
                    $rangee['product_name_2'] = str_replace(')', '',$rangee['product_name_2']);
                    $resultat[] = $rangee;
                }
                return $resultat;
            }
            return false;
        }

        public static function getOrdersByZone($zone = 0)
        {
            if ( $zone <> 0 )
            {
                if ( $zone == -4 )
                {
                    $cmds1 = Order::getOrderIdsByStatusByZone(2, 0, $zone); // Paiement accepté
                    $cmds2 = Order::getOrderIdsByStatusByZone(3, 0, $zone); // Préparation en cours
                    $cmds3 = Order::getOrderIdsByStatusByZone(18, 0, $zone); // Nous partons arracher votre rosier !
                    //$cmds3 = Order::getOrderIdsByStatusByZone(43, 0, $zone); // Préparation en cours - Picking OK
                    //$cmds4 = Order::getOrderIdsByStatusByZone(20, 0, $zone); // Préparation en cours - Etiquette OK
                    //$cmds5 = Order::getOrderIdsByStatusByZone(4, 0, $zone); // En cours de livraison
                    //$cmds6 = Order::getOrderIdsByStatusByZone(42, 0, $zone); // Colis disponible au point de retrait Click and Collect
                    //$cmds_final = array_merge($cmds1, $cmds2, $cmds3);
                    $cmds_final = array_merge($cmds1, $cmds2, $cmds3);
                }
                else 
                {
                    $cmds1 = Order::getOrderIdsByStatusByZone(2, 0, $zone); // Paiement accepté
                    $cmds2 = Order::getOrderIdsByStatusByZone(3, 0, $zone); // Préparation en cours
                    //$cmds3 = Order::getOrderIdsByStatusByZone(43, 0, $zone); // Préparation en cours - Picking OK
                    //$cmds4 = Order::getOrderIdsByStatusByZone(20, 0, $zone); // Préparation en cours - Etiquette OK
                    //$cmds5 = Order::getOrderIdsByStatusByZone(4, 0, $zone); // En cours de livraison
                    //$cmds6 = Order::getOrderIdsByStatusByZone(42, 0, $zone); // Colis disponible au point de retrait Click and Collect
                    //$cmds_final = array_merge($cmds1, $cmds2, $cmds3);
                    $cmds_final = array_merge($cmds1, $cmds2);
                }
                
                return $cmds_final;
            }
            return false;
        }

        public static function getOrdersByZoneDEV($zone = 0)
        {
            if ( $zone <> 0 )
            {
                if ( $zone == -4 )
                {
                    $cmds1 = Order::getOrderIdsByStatusByZone(2, 0, $zone); // Paiement accepté
                    $cmds2 = Order::getOrderIdsByStatusByZone(3, 0, $zone); // Préparation en cours
                    $cmds3 = Order::getOrderIdsByStatusByZone(18, 0, $zone); // Nous partons arracher votre rosier !
                    //$cmds3 = Order::getOrderIdsByStatusByZone(43, 0, $zone); // Préparation en cours - Picking OK
                    //$cmds4 = Order::getOrderIdsByStatusByZone(20, 0, $zone); // Préparation en cours - Etiquette OK
                    //$cmds5 = Order::getOrderIdsByStatusByZone(4, 0, $zone); // En cours de livraison
                    //$cmds6 = Order::getOrderIdsByStatusByZone(42, 0, $zone); // Colis disponible au point de retrait Click and Collect
                    //$cmds_final = array_merge($cmds1, $cmds2, $cmds3);
                    $cmds_final = array_merge($cmds1, $cmds2, $cmds3);
                }
                else 
                {
                    $cmds1 = Order::getOrderIdsByStatusByZone(2, 0, $zone); // Paiement accepté
                    $cmds2 = Order::getOrderIdsByStatusByZone(3, 0, $zone); // Préparation en cours
                    $cmds3 = Order::getOrderIdsByStatusByZone(43, 0, $zone); // Préparation en cours - Picking OK
                    $cmds4 = Order::getOrderIdsByStatusByZone(20, 0, $zone); // Préparation en cours - Etiquette OK
                    //$cmds5 = Order::getOrderIdsByStatusByZone(4, 0, $zone); // En cours de livraison
                    //$cmds6 = Order::getOrderIdsByStatusByZone(42, 0, $zone); // Colis disponible au point de retrait Click and Collect
                    //$cmds_final = array_merge($cmds1, $cmds2, $cmds3);
                    $cmds_final = array_merge($cmds1, $cmds2, $cmds3, $cmds4);
                }
                
                return $cmds_final;
            }
            return false;
        }

        public static function getOrdersByDeuxZones($zone1 = 0, $zone2 = 0)
        {
            if ( $zone1 <> 0 && $zone2 <> 0 )
            {
                $cmds1 = Order::getOrderIdsByStatusByDeuxZones(2, 0, $zone1, $zone2); // Paiement accepté
                $cmds2 = Order::getOrderIdsByStatusByDeuxZones(3, 0, $zone1, $zone2); // Préparation en cours
                //$cmds3 = Order::getOrderIdsByStatusByZone(43, 0, $zone); // Préparation en cours - Picking OK
                //$cmds4 = Order::getOrderIdsByStatusByZone(20, 0, $zone); // Préparation en cours - Etiquette OK
                //$cmds5 = Order::getOrderIdsByStatusByZone(4, 0, $zone); // En cours de livraison
                //$cmds6 = Order::getOrderIdsByStatusByZone(42, 0, $zone); // Colis disponible au point de retrait Click and Collect
                //$cmds_final = array_merge($cmds1, $cmds2, $cmds3);
                $cmds_final = array_merge($cmds1, $cmds2);
                
                return $cmds_final;
            }
            return false;
        }        

        public static function getZones($id_zone = 0)
        {
            $req = new DbQuery();
            $req->select('lgz.id_zone, lgz.libelle_zone, lgz.couleur_zone');
            $req->from('LogiGraine_admin_zone', 'lgz');
            if ( $id_zone <> 0 )
            {
                $req->where('lgz.id_zone = "'.$id_zone.'"');
            } 
            $req->orderBy('lgz.`ordre_zone` ASC');
            
            $resu = Db::getInstance(_PS_USE_SQL_SLAVE_)->executeS($req);
            return $resu;
        }

        public static function getPdas($id_pda = 0)
        {
            $req = new DbQuery();
            $req->select('lgp.id_pda, lgp.nom_pda, lgo.prenom_operateur, lgo.nom_operateur');
            $req->from('LogiGraine_pda', 'lgp');
            $req->leftJoin('LogiGraine_pda_operateur', 'lgpo', 'lgp.id_pda = lgpo.id_pda');
            $req->leftJoin('LogiGraine_operateur', 'lgo', 'lgpo.id_operateur = lgo.id_operateur');
            if ( $id_pda <> 0 )
            {
                $req->where('lgp.id_pda = "'.$id_pda.'"');
            } 
            //$req->orderBy('lgp.`nom_pda` ASC');
            $req->orderBy('lgo.`prenom_operateur` ASC');
            
            $resu = Db::getInstance(_PS_USE_SQL_SLAVE_)->executeS($req);
            return $resu;
        }

        public static function getZoneByOrder($id_order = 0)
        {
            if ( $id_order > 0 )
            {
                $zone1 = Order::getOrderIdsByStatusByZone(0, 0, 1, $id_order);
                $zone2 = Order::getOrderIdsByStatusByZone(0, 0, 2, $id_order);
                $zone3 = Order::getOrderIdsByStatusByZone(0, 0, 3, $id_order);
                $zone4 = Order::getOrderIdsByStatusByZone(0, 0, 4, $id_order);
                $zone5 = Order::getOrderIdsByStatusByZone(0, 0, 5, $id_order);
                $zonelv = Order::getOrderIdsByStatusByZone(0, 0, -2, $id_order);
                $zoner = Order::getOrderIdsByStatusByZone(0, 0, -4, $id_order);
                $zonem = Order::getOrderIdsByStatusByZone(0, 0, -1, $id_order);

                if (in_array($id_order, $zone1))
                {
                    return 'Graines';
                }
                if (in_array($id_order, $zone2))
                {
                    return 'Bulbes potagers';
                }
                if (in_array($id_order, $zone3))
                {
                    return 'Chambre 2';
                }
                if (in_array($id_order, $zone4))
                {
                    return 'Extérieur';
                }
                if (in_array($id_order, $zone5))
                {
                    return 'Accessoires';
                }
                if (in_array($id_order, $zonelv))
                {
                    return 'Lettres vertes';
                }
                if (in_array($id_order, $zoner))
                {
                    return 'Rosiers';
                }
                if (in_array($id_order, $zonem))
                {
                    return 'Mixtes';
                }
                return 'Inconnu';
            }
            return false;
        }

        public static function getGroups($orders)
        {
            foreach($orders as $cmdEC)
            {
                $listeArt = Commande::getProductsByOrder($cmdEC);
                $articles = array();
                foreach($listeArt as $artEC)
                {
                    $req_emp = 'SELECT etagere_plan FROM ps_LogiGraine_plan WHERE REPLACE(debut_plan,"-","") <= "'.str_replace('-', '', $artEC['product_reference']).'" AND REPLACE(fin_plan,"-","") >= "'.str_replace('-', '', $artEC['product_reference']).'" LIMIT 0,1;';
                    //echo $req_emp.'<br />';
                    $resu_emp = Db::getInstance(_PS_USE_SQL_SLAVE_)->executeS($req_emp);
                    if ( !isset($resu_emp[0]['etagere_plan']) )
                    {
                        $resu_emp[0]['etagere_plan'] = '-';
                    }
                    $articles[] = array($artEC['product_ean13'], $artEC['quantity_final'], $resu_emp[0]['etagere_plan']);
                }
                $commandes[$cmdEC] = $articles;
            }

            $optimizer = new WarehouseTopologyOptimizer();

            return $optimizer->optimizeOrders($commandes);
        }
    }

    class WarehouseTopologyOptimizer {
        private $shelves = [
            'A' => ['A01', 'A02', 'A03', 'A04', 'A05', 'A06', 'A07', 'A08', 'A09', 'A10', 'A11'],
            'B' => ['B01', 'B02', 'B03', 'B04', 'B05', 'B06', 'B07', 'B08', 'B09'],
            'C' => ['C01', 'C02', 'C03', 'C04', 'C05', 'C06', 'C07', 'C08', 'C09'],
            'D' => ['D01', 'D02', 'D03', 'D04', 'D05', 'D06', 'D07', 'D08'],
            'E' => ['E01', 'E02', 'E03', 'E04', 'E05', 'E06', 'E07', 'E08'],
            'F' => ['F01', 'F02', 'F03', 'F04', 'F05', 'F06', 'F07', 'F08'],
            'G' => ['G01', 'G02', 'G03', 'G04', 'G05', 'G06', 'G07', 'G08']
        ];
    
        private $facingRacks = [
            'A' => 'B',
            'B' => 'A',
            'C' => 'D',
            'D' => 'C',
            'E' => 'F',
            'F' => 'E'
        ];
    
        private $backToBackRacks = [
            'B' => 'C',
            'C' => 'B',
            'D' => 'E',
            'E' => 'D',
            'F' => 'G',
            'G' => 'F'
        ];
    
        // Définition des allées optimales de préparation
        private $pickingAisles = [
            ['A', 'B'],    // Allée 1
            ['C', 'D'],    // Allée 2
            ['E', 'F'],    // Allée 3
            ['G']          // Allée 4
        ];
    
        /**
         * Optimise les groupes de commandes en tenant compte de la topologie
         */
        public function optimizeOrders(array $orders): array {
            // Analyser les commandes pour créer des vecteurs de caractéristiques
            $orderVectors = $this->createOrderVectors($orders);
            
            // Regrouper les commandes en utilisant K-means modifié
            $groups = $this->groupOrders($orderVectors);
            
            // Optimiser chaque groupe
            return $this->optimizeGroups($groups, $orders);
        }
    
        /**
         * Crée des vecteurs de caractéristiques pour chaque commande
         */
        private function createOrderVectors(array $orders): array {
            $vectors = [];
            foreach ($orders as $orderId => $items) {
                $vector = [];
                // Créer un vecteur pour chaque allée
                foreach ($this->pickingAisles as $aisleIndex => $aisleRacks) {
                    $vector["aisle_$aisleIndex"] = 0;
                    foreach ($items as $item) {
                        $rack = substr($item[2], 0, 1);
                        if (in_array($rack, $aisleRacks)) {
                            $vector["aisle_$aisleIndex"]++;
                        }
                    }
                }
                $vectors[$orderId] = $vector;
            }
            return $vectors;
        }
    
        /**
         * Regroupe les commandes en utilisant un K-means modifié
         */
       /* private function groupOrders(array $vectors): array {
            $k = ceil(count($vectors) / 4); // Nombre de groupes nécessaires
            $groups = [];
            
            // Initialiser les centroids basés sur les allées
            $centroids = $this->initializeCentroids($vectors, $k);
            echo '<pre>';
            print_r($centroids);
            echo '</pre>';
            die;
            do {
                $changed = false;
                $newGroups = array_fill(0, $k, []);
                
                // Assigner chaque commande au groupe le plus compatible
                foreach ($vectors as $orderId => $vector) {
                    $bestGroup = $this->findBestGroup($vector, $centroids);
                    $newGroups[$bestGroup][] = $orderId;
                }
                
                // Mettre à jour les centroids
                foreach ($newGroups as $groupId => $groupOrders) {
                    if (!empty($groupOrders)) {
                        $newCentroid = $this->calculateCentroid(
                            array_intersect_key($vectors, array_flip($groupOrders))
                        );
                        if ($newCentroid !== $centroids[$groupId]) {
                            $centroids[$groupId] = $newCentroid;
                            $changed = true;
                        }
                    }
                }
                
                $groups = $newGroups;
            } while ($changed);
            
            return $this->balanceGroups($groups);
        }*/
    
        /**
         * Optimise le chemin de picking pour chaque groupe
         */
        private function optimizeGroups(array $groups, array $orders): array {
            $optimizedGroups = [];
            
            foreach ($groups as $group) {
                if (empty($group)) continue;
                
                $groupOrders = array_intersect_key($orders, array_flip($group));
                $pickingPath = $this->calculateOptimalPath($groupOrders);
                
                $optimizedGroups[] = [
                    'orders' => $groupOrders,
                    'picking_path' => $pickingPath,
                    'sequence' => $this->generatePickingSequence($groupOrders, $pickingPath)
                ];
            }
            
            return $optimizedGroups;
        }
    
        /**
         * Calcule le chemin optimal en tenant compte des allées
         */
        private function calculateOptimalPath(array $orders): array {
            $aisleVisits = [];
            
            // Identifier quelles allées doivent être visitées
            foreach ($this->pickingAisles as $aisleIndex => $aisleRacks) {
                foreach ($orders as $items) {
                    foreach ($items as $item) {
                        $rack = substr($item[2], 0, 1);
                        if (in_array($rack, $aisleRacks)) {
                            $aisleVisits[$aisleIndex] = true;
                            break 2;
                        }
                    }
                }
            }
            
            // Optimiser l'ordre des allées
            return $this->optimizeAisleSequence(array_keys($aisleVisits));
        }
    
        /**
         * Génère la séquence détaillée de picking
         */
        private function generatePickingSequence(array $orders, array $path): array {
            $sequence = [];
            
            foreach ($path as $aisleIndex) {
                $aisleRacks = $this->pickingAisles[$aisleIndex];
                $aisleItems = [];
                
                // Collecter tous les items de l'allée
                foreach ($orders as $orderId => $items) {
                    foreach ($items as $item) {
                        $rack = substr($item[2], 0, 1);
                        if (in_array($rack, $aisleRacks)) {
                            $aisleItems[] = [
                                'order_id' => $orderId,
                                'location' => $item[2],
                                'ean' => $item[0],
                                'quantity' => $item[1]
                            ];
                        }
                    }
                }
                
                // Optimiser l'ordre des items dans l'allée
                $sequence[] = [
                    'aisle' => $aisleIndex,
                    'items' => $this->optimizeAisleItems($aisleItems, $aisleRacks)
                ];
            }
            
            return $sequence;
        }
    
        /**
         * Optimise l'ordre des items dans une allée
         */
        private function optimizeAisleItems(array $items, array $racks): array {
            usort($items, function($a, $b) use ($racks) {
                $rackA = substr($a['location'], 0, 1);
                $rackB = substr($b['location'], 0, 1);
                
                if ($rackA === $rackB) {
                    return strcmp($a['location'], $b['location']);
                }
                
                return array_search($rackA, $racks) - array_search($rackB, $racks);
            });
            
            return $items;
        }
    
        /**
         * Équilibre les groupes pour avoir environ 3 commandes par groupe
         */
        private function balanceGroups(array $groups): array {
            $balanced = [];
            $currentGroup = [];
            $count = 0;
            
            foreach ($groups as $group) {
                foreach ($group as $orderId) {
                    $currentGroup[] = $orderId;
                    $count++;
                    
                    if ($count >= 3) {
                        $balanced[] = $currentGroup;
                        $currentGroup = [];
                        $count = 0;
                    }
                }
            }
            
            if (!empty($currentGroup)) {
                $balanced[] = $currentGroup;
            }
            
            return $balanced;
        }
         
        /**
         * Calcule le centroid d'un groupe de vecteurs
         */
        private function calculateCentroid(array $vectors): array {
            if (empty($vectors)) {
                return [];
            }
    
            $centroid = [];
            $numVectors = count($vectors);
            
            // Obtenir toutes les clés possibles
            $keys = [];
            foreach ($vectors as $vector) {
                $keys = array_unique(array_merge($keys, array_keys($vector)));
            }
            
            // Calculer la moyenne pour chaque dimension
            foreach ($keys as $key) {
                $sum = 0;
                foreach ($vectors as $vector) {
                    $sum += $vector[$key] ?? 0;
                }
                $centroid[$key] = $sum / $numVectors;
            }
            
            return $centroid;
        }
    
        /**
         * Initialise les centroids pour le clustering K-means
         */
        private function initializeCentroids(array $vectors, int $k): array {
            if (empty($vectors)) {
                throw new RuntimeException("Impossible d'initialiser les centroids : aucun vecteur fourni");
            }
    
            $centroids = [];
            $vectorKeys = array_keys($vectors);
            $firstVector = reset($vectors);
            
            // S'assurer que k est valide
            $k = min($k, count($vectors));
            $k = max(1, $k); // Au moins 1 centroid
            
            // Initialiser avec des vecteurs réels
            for ($i = 0; $i < $k; $i++) {
                if (isset($vectorKeys[$i])) {
                    $centroids[] = $vectors[$vectorKeys[$i]];
                } else {
                    // Si pas assez de vecteurs, utiliser le premier avec une petite variation
                    $newCentroid = $firstVector;
                    array_walk($newCentroid, function(&$value) {
                        $value += rand(-1, 1); // Petite variation aléatoire
                    });
                    $centroids[] = $newCentroid;
                }
            }
    
            return $centroids;
        }
    
        /**
         * Trouve le meilleur groupe pour un vecteur donné
         */
        private function findBestGroup(array $vector, array $centroids): int {
            if (empty($centroids)) {
                return 0;
            }
    
            $minDistance = PHP_FLOAT_MAX;
            $bestGroup = 0;
            
            foreach ($centroids as $groupId => $centroid) {
                // Vérifier que le centroid est valide
                if (!is_array($centroid) || empty($centroid)) {
                    continue;
                }
                
                try {
                    $distance = $this->calculateDistance($vector, $centroid);
                    if ($distance < $minDistance) {
                        $minDistance = $distance;
                        $bestGroup = $groupId;
                    }
                } catch (Exception $e) {
                    // Log l'erreur et continuer avec le prochain centroid
                    error_log("Erreur lors du calcul de distance : " . $e->getMessage());
                    continue;
                }
            }
            
            return $bestGroup;
        }
    
        /**
         * Calcule la distance entre deux vecteurs
         */
        private function calculateDistance(array $vector1, array $vector2): float {
            if (empty($vector2)) {
                throw new InvalidArgumentException("Le second vecteur ne peut pas être vide");
            }
    
            // S'assurer que les deux vecteurs ont les mêmes clés
            $allKeys = array_unique(array_merge(array_keys($vector1), array_keys($vector2)));
            $sum = 0;
    
            foreach ($allKeys as $key) {
                $v1 = $vector1[$key] ?? 0;
                $v2 = $vector2[$key] ?? 0;
                $sum += pow($v1 - $v2, 2);
            }
    
            return sqrt($sum);
        }
    
        /**
         * Regroupe les commandes en utilisant un K-means modifié
         */
        private function groupOrders(array $vectors): array {
            if (empty($vectors)) {
                return [];
            }
    
            $k = max(1, ceil(count($vectors) / 3)); // Au moins 1 groupe
            $groups = [];
            $maxIterations = 100; // Éviter les boucles infinies
            
            try {
                // Initialiser les centroids
                $centroids = $this->initializeCentroids($vectors, $k);
                
                $iteration = 0;
                do {
                    $changed = false;
                    $newGroups = array_fill(0, $k, []);
                    
                    // Assigner chaque commande au groupe le plus proche
                    foreach ($vectors as $orderId => $vector) {
                        $bestGroup = $this->findBestGroup($vector, $centroids);
                        $newGroups[$bestGroup][] = $orderId;
                    }
                    
                    // Mettre à jour les centroids
                    foreach ($newGroups as $groupId => $groupOrders) {
                        if (empty($groupOrders)) {
                            continue;
                        }
                        
                        $groupVectors = array_intersect_key($vectors, array_flip($groupOrders));
                        $newCentroid = $this->calculateCentroid($groupVectors);
                        
                        if (!isset($centroids[$groupId]) || $newCentroid !== $centroids[$groupId]) {
                            $centroids[$groupId] = $newCentroid;
                            $changed = true;
                        }
                    }
                    
                    $groups = $newGroups;
                    $iteration++;
                    
                } while ($changed && $iteration < $maxIterations);
                
            } catch (Exception $e) {
                // En cas d'erreur, créer des groupes simples de 3 commandes
                error_log("Erreur lors du clustering : " . $e->getMessage());
                $groups = [];
                $currentGroup = [];
                foreach ($vectors as $orderId => $vector) {
                    $currentGroup[] = $orderId;
                    if (count($currentGroup) >= 3) {
                        $groups[] = $currentGroup;
                        $currentGroup = [];
                    }
                }
                if (!empty($currentGroup)) {
                    $groups[] = $currentGroup;
                }
            }
            
            return $this->balanceGroups($groups);
        }
    
        /**
         * Optimise l'ordre des allées pour minimiser la distance totale
         */
        private function optimizeAisleSequence(array $aisleIndices): array {
            if (count($aisleIndices) <= 2) {
                return $aisleIndices;
            }
    
            // Utiliser un algorithme glouton simple pour l'ordre des allées
            $sequence = [$aisleIndices[0]];
            $remaining = array_slice($aisleIndices, 1);
            
            while (!empty($remaining)) {
                $lastAisle = end($sequence);
                $bestNextAisle = null;
                $bestDistance = PHP_FLOAT_MAX;
                
                foreach ($remaining as $index => $aisle) {
                    $distance = abs($lastAisle - $aisle);
                    if ($distance < $bestDistance) {
                        $bestDistance = $distance;
                        $bestNextAisle = $index;
                    }
                }
                
                $sequence[] = $remaining[$bestNextAisle];
                unset($remaining[$bestNextAisle]);
                $remaining = array_values($remaining);
            }
            
            return $sequence;
        }
    }
?>